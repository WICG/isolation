<pre class="metadata">
Title: Isolated Origins
Status: DREAM
Shortname: origin-isolation
Level: None
Editor: Emily Stark
Editor: Tanvi Vyas
Editor: Mike West
Editor: Joel Weinberger
Abstract: Isolation: Good feature, or the best feature?
Indent: 2
Version History: https://github.com/mikewest/isolation/commits/master/index.src.html
!Participate: <a href="https://github.com/mikewest/isolation/issues/new">File an issue</a> (<a href="https://github.com/mikewest/isolation/issues">open issues</a>)
Markup Shorthands: css off, markdown on
</pre>

<pre class="anchors">
spec: HTML; urlPrefix: https://html.spec.whatwg.org/
  type: dfn
    text: initialising a new document object; url: initialise-the-document-object
    text: storage object initialisation steps; url: storage-object-initialisation-steps
    text: Storage; url: storage-2
</pre>

Introduction {#intro}
============

Authors of security-critical applications want the web's low-friction install process, its
linkability, and its cross-platform nature, but are understandably nervous about hosting very
powerful applications on the web alongside malicious content that can attack in any number of ways.
For example, malicious content can:

- Exploit cross-site scripting (XSS) or cross-site request forgery (CSRF) vulnerabilities to steal
  sensitive user data or take actions on a user's behalf.

- Trick the user into revealing data or taking actions via clickjacking attacks.

- Navigate a security-critical application to a phishing page without the user noticing.

- Leverage a browser vulnerability to gain access to data from other origins (universal XSS or
  UXSS).

Security-critical applications should be able to run in a browser with a degree of isolation that
mitigates these attacks. This specification defines an isolation mechanism that an origin can opt in
to, thereby reducing its exposure to other web content. Developers responsible for security-critical
web applications can choose to trade away some of the features of being on the open web (such as
full linkability) in exchange for better protection from malicious web content.

Threat Model {#threat}
------------

MegaCorp, Inc. has deployed a security-critical application on `example.com`. Malicious attackers
in control of `evil.com` might attack this application in a number of ways which this document aims
to address:

1.  `evil.com` might cause the user's browser to send a request to `example.com` that exploits a
    cross-site scripting (XSS) or cross-site request forgery (CSRF) vulnerability. Such
    vulnerabilities might be triggered by navigational requests (via <{iframe}> or
    {{Window/open()}}), or by subresource requests (via <{img}>, etc).

2.  `example.com` might open a link to `evil.com` (for example, user-generated content could include
    an auto-linked reference to that origin). This allows `evil.com` to obtain a reference to the
    `example.com` window via the <a attribute lt="opener">`window.opener`</a> attribute, which opens
    up communication channels ({{Window/postMessage()}}, frame counting and traversal, etc.) that
    `example.com` might not be expecting.

3.  Likewise, `evil.com` can obtain such a reference via {{Window/open()}}.

4.  `evil.com` might exploit a vulnerability in the browser itself (UXSS) to gain access to
    `example.com` data and cookies.

    Note: The mechanism proposed in this document does not aim to give hard guarantees about
    protection from UXSS, but does hope to mitigate some of the risks on a best-effort basis.

5.  `evil.com` might be able to extract data from `example.com` by loading its resources
    or framing its content. Extraction techniques could range from exploitation of overly-broad CORS
    headers, to timing attacks like [[HEIST]], [[PIXEL-PERFECT]], etc.

6.  `evil.com` might be able to extract data from `example.com`'s cross-site
    dependencies (say `investments-r-us.biz`), as its users may authenticate to these dependencies,
    then exposing that ambient authority to attack.

7.  `evil.com` and `example.com` might in fact be `evil.example.com` and `app.example.com`, in which
    case:

    1.  `evil.example.com` might try to set a cookie for all of `example.com` in hopes that it can
        fix a session or CSRF token for the user on `app.example.com`, or exploit .

    2.  `evil.example.com` might take advantage of `app.example.com`'s (ill-advised) loosening of
        the same-origin policy via {{Document}}'s {{Document/domain}} attribute.

Mitigation Strategy {#strategy}
-------------------

To address the threats above, this document details an origin-wide isolation mechanism that aims to
break the communication channels between `example.com` and `evil.com`. When MegaCorp, Inc. opts-in
to this mechanism, the user agent will enforce the following:

1.  Resources from `example.com` may not be framed by cross-origin contexts. That is, the user
    agent will act as though `Content-Security-Policy: frame-ancestors 'self'` is delivered with
    each resource. This prevents `evil.com` from exploiting attacks that require control over
    `example.com`'s browsing context ([[PIXEL-PERFECT]], as well as straightforward clickjacking),
    or access to `example.com`'s {{Window}} (via {{HTMLIFrameElement/contentWindow}}).

2.  Cross-origin resources which `example.com` frames are not given access to `window.top` or
    `window.parent` (those accessors will return `null`). This prevents `evil.com` from exploiting
    attacks which require access to `example.com`'s {{Window}}, or navigating the user to an
    unexpected URL to replace `example.com` in the top-level browsing context.

3.  When `example.com` opens a new, cross-origin window (via {{Window/open()}},
    `<a target="_blank">...</a>`, etc.), the new window will <a>disown its opener</a>, and the
    call to {{Window/open()}} will return `null`. That is, the user agent will act as though
    <a>noopener</a> is specified on outgoing links and {{Window/open()}} calls.

    Likewise, when `example.com` is opened from a cross-origin window, it will <a>disown its
    opener</a>, and the return value of {{Window/open()}} in the opener context will be `null`.

4.  Something something cookies.

    ISSUE: I have no idea what makes sense here.

5.  Something something cross-origin navigation to `example.com`.

    ISSUE: Force preflights for navigational requests from `evil.com` to `example.com`. A non-2XX
    response will result in returning a synthetic client-side redirect response to the root of the
    origin.

6.  Something something cross-origin subresources loaded from `example.com`.

    ISSUE: Should we allow subresource requests from `evil.com` to `example.com` at all? If not,
    easy: network error. If so, we need to either double-key `example.com`'s cookies, or ensure
    that they're all treated as `SameSite=Strict`.

7.  The user agent should load `example.com` into a separate process from other web content.

    Note: This is not a firm guarantee (especially since not all browsers implement per-site process
    isolation at all), but rather a best-effort attempt to mitigate the risks of UXSS bugs.


Key Concepts {#concepts}
============

An <dfn>isolated origin</dfn> is an <a for="/">origin</a> that has opted in to isolate itself from
other origins on the web, using the mechanisms defined in this specification.

User agents have an <dfn>isolated origin store</dfn>, which is a set of <a for="/">origins</a> that
wish to be isolated.

When asked <dfn algorithm local-lt="is-origin-isolated">if an origin is isolated</dfn>, an
<a>isolated origin store</a> returns true if the given origin is present in the set and false
otherwise.

When asked to <dfn algorithm local-lt="isolate-an-origin">isolate an origin</dfn>, an <a>isolated
origin store</a> adds the given origin to the set.

When asked to <dfn algorithm local-lt="deisolate-an-origin">de-isolate an origin</dfn>, an
<a>isolated origin store</a> removes the given origin from the set.

Delivery {#delivery}
============

ISSUE: define an HTTP header that is processed in Fetch and calls isolate-an-origin or
deisolate-an-origin

ISSUE: the isolate-me HTTP header needs to be sent and/or processed before the Set-Cookie header...

Integrations {#integrations}
============

Integration with Cookies {#cookies}
------------

This section defines modifications to [[!COOKIES]] to support isolated origins.

### Forcing cookies to be same-site ### {#forcing-cookies-samesite}

When receiving a cookie from a request-uri whose origin is an <a>isolated origin</a>, Section 5.3
should be modified to set the cookie's `samesite-flag` field to "Strict" if the request-uri's <a
lt="is-origin-isolated">origin is isolated</a>.

### Double-keyed storage ### {#double-keyed-cookies}

ISSUE: add an isolated-origin flag to cookies. When a cookie is set and the top-level site is an
isolated origin, then set the isolated-origin flag on the cookie. When constructing a Cookie header,
don't include cookies whose isolated-origin flag is set to an origin that is not the origin of the
top-level site.

ISSUE: these cookie changes don't prevent all session fixation attacks. If a user has never visited
victim.example.com before, evil.example.com can set a cookie for .example.com, which will be sent on
the request when the user first navigates to victim.example.com. The isolated origin can mitigate
this by using __Host- cookies for sensitive cookies. Maybe isolated origins should be required to
use __Host- on all cookies.

Integration with HTML {#html}
------------

### Cross-origin framing of isolated origins ### {#cross-origin-framing}

Step 1 of <a>Process a navigate response</a> should be modified to call
[[#should-block-navigation-response]], so that cross-origin framing of isolated origins is not
allowed.

### DOM storage ### {#dom-storage}

When an origin becomes isolated, it should use its own DOM storage separate from what it used before
being isolated.

#### `localStorage` #### {#localstorage}

Instead of providing a <a>Storage</a> object for each <a for="/">origin</a>, the `localStorage`
object should provide two <a>Storage</a> objects, one for isolated origins and one for non-isolated
origins. Step 3 of
<a lt="storage object initialisation steps">the `Storage` object initialization steps</a> for
`localStorage` should be modified to read as follows:

3. Check to see if the user agent has allocated a local storage area for the `(origin, isolated)`
   pair, where `origin` is the <a for="/">origin</a> of the <a>Document</a> of the <a>Window</a>
   object on which the attribute was accessed, and `isolated` is a boolean flag that is true if the
   <a for="/">origin</a> is an <a>isolated origin</a> and false otherwise. If it has not, create a
   new storage area for that `(origin, isolated)` pair.

#### `sessionStorage` #### {#sessionstorage}

ISSUE: Modify sessionStorage to associate one Storage object per (origin, top level isolated origin)
pair.

### Disowning isolated openers ### {#disown-opener}

When an isolated origin opens a new window to a different origin, that origin should not be able to
manipulate the isolated origin via the `window.opener` attribute.

<a>Initializing a new Document object</a> should be modified to call [[#disown-isolated-opener]] on
|browsingContext| and the <a>response</a> used to generate the document.

### Removing cross-origin subframe references ### {#remove-cross-origin-subframe-references}

When an isolated origin embeds cross-origin subframes, those subframes should not be able to obtain
references to the isolated origin's window via `window.top` or `window.parent`.

The <a attribute lt="top" for="/">`window.top`</a> attribute algorithm should be modified to return
null if `context`'s <a>top-level browsing context</a>'s <a>active document</a>'s
<a for="Document">origin</a> is an <a>isolated origin</a>.

Similarly, the <a attribute lt="parent" for="/">`window.parent`</a> attribute algorithm should be
modified to return null if `context`'s <a>top-level browsing context</a>'s <a>active document</a>'s
<a for="Document">origin</a> is an <a>isolated origin</a>.

Algorithms {#algorithms}
============

<h3 id="should-block-navigation-response" algorithm>
    Should |navigation response| in |target| be blocked?
</h3>

Given a <a>response</a> (|navigation response|) and a <a>browsing context</a> (|target|), this
algorithm returns "`Blocked`" if |navigation response| is from an isolated origin and one or more of
the ancestors of |target| is cross-origin.

1. If |target| is not a <a>nested browsing context</a>, return "`Allowed`".

2. Let |navigation origin| be the result of executing the <a>URL parser</a> on the <a lt="unicode
   serialization of an origin">unicode serialization</a> of |navigation response|'s <a
   for="response">url</a>'s {{URL/origin}}.

3. If |navigation origin| is not <a lt="is-origin-isolated">an isolated origin</a>, return
  "`Allowed`".

4. Let |current| be |target|.

5. While |current| has a <a>parent browsing context</a> (|parent|):
  1. Set |current| to |parent|.
  2. Let |origin| be the result of executing the <a>URL parser</a> on the <a lt="unicode
     serialization of an origin">unicode serialization</a> of |parent|'s <a>active document</a>'s
     <a>relevant settings object</a>'s <a for="environment settings object">origin</a>.
  3. If |origin| is not <a>same origin</a> with |navigation origin|, return "`Blocked`".

6. Return "`Allowed`".

<h3 id="disown-isolated-opener" algorithm>
    Disown an isolated opener
</h3>

Given a <a>browsing context</a> (|browsingContext|) and a <a>response</a> (|response|) used to
generate a <a>document</a>, this algorithm disowns |browsingContext|'s opener if the opener is an
isolated origin.

1. If |browsingContext| does not have an <a>opener browsing context</a>, then abort these steps.

2. Let |openedOrigin| be the result of executing the <a>URL parser</a> on the <a lt="unicode
   serialization of an origin">unicode serialization</a> of |response|'s <a for="response">url</a>'s
   {{URL/origin}}.

3. Let |openerOrigin| be the result of executing the <a>URL parser</a> on the <a lt="unicode
   serialization of an origin">unicode serialization</a> of |browsingContext|'s <a>opener browsing
   context</a>'s <a>active document</a>'s <a>relevant settings object</a>'s
   <a for="environment settings object">origin</a>.

4. If |openedOrigin| is <a>same origin</a> with |openerOrigin|, then abort these steps.

5. If |openerOrigin| <a lt="is-origin-isolated">is an isolated origin</a>, then |browsingContext|
   should <a>disown its opener</a>.

Security Considerations {#security}
============

Privacy Considerations {#privacy}
============
